{
  "hash": "93467b6b8c6fba3dc2fd730937ac817f",
  "result": {
    "markdown": "---\ntitle: \"Take-Home_Ex1\"\nauthor: \"Roger\"\neditor: visual\n---\n\n\n# 1. Overview\n\nWater is an important resource to mankind. Clean and accessible water is critical to human health. It provides a healthy environment, a sustainable economy, reduces poverty and ensures peace and security. Yet over 40% of the global population does not have access to sufficient clean water. By 2025, 1.8 billion people will be living in countries or regions with absolute water scarcity, according to UN-Water. The lack of water poses a major threat to several sectors, including food security. Agriculture uses about 70% of the world's accessible freshwater.\n\nDeveloping countries are most affected by water shortages and poor water quality. Up to 80% of illnesses in the developing world are linked to inadequate water and sanitation. Despite technological advancement, providing clean water to the rural community is still a major development issues in many countries globally, especially countries in the Africa continent.\n\nTo address the issue of providing clean and sustainable water supply to the rural community, a global [Water Point Data Exchange (WPdx)](https://www.waterpointdata.org/about/) project has been initiated. The main aim of this initiative is to collect water point related data from rural areas at the water point or small water scheme level and share the data via WPdx Data Repository, a cloud-based data library. What is so special of this project is that data are collected based on [WPDx Data Standard](https://www.waterpointdata.org/wp-content/uploads/2021/04/WPDx_Data_Standard.pdf).\n\n## 1.1 Objectives\n\nGeospatial analytics hold tremendous potential to address complex problems facing society. In this study, appropriate global and local measures of spatial Association techniques will be applied to reveal the spatial patterns of Not Functional water points. For the purpose of this study, Nigeria will be used as the study country.\n\nIn the code chunk below, p_load(0 of pacman package is used to load the following R packages into R environment:\n\n-   sf\n\n-   spdep\n\n-   tmap\n\n-   tidyverse\n\n-   funModeling (used for rapid Exploratory Data Analysis)\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, spdep, tmap, tidyverse, funModeling)\n```\n:::\n\n\n# 2. Data Acquisition\n\n## 2.1 Importing the geospatial data\n\nFor this study, two geospatial data will be used:\n\n### 2.1.1 Importing water point geospatial data\n\n-   The water point geospatial data will be downloaded from [WPdx Global Data Repositories](https://www.waterpointdata.org/access-data/), specifically the WPdx+ data set will be used. In the code chunk below, we will import the shapefile as simple features data table into R environment using st_read() of sf package. filter() of dplyr will be used to extract water point records of Nigeria.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwp <- st_read(dsn = \"data\",\n              layer= \"geo_export\",\n              crs = 4326) %>%\n  filter(clean_coun == \"Nigeria\")\n```\n:::\n\n\nNext, write_rds() of readr package is used to save the extracted sf data table (i.e. wp) into an output file in rds data format, and saved in the data sub-folder.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(wp, \"data/wp_nga.rds\")\n```\n:::\n\n\n### 2.1.2 Importing Nigeria LGA boundary geospatial data\n\n-   The Nigeria Level-2 Administrative Boundary (also known as Local Government Area) polygon features GIS data will be the second data set used in this study. The data is downloaded from [geoBoundaries](https://www.geoboundaries.org/). In the code chunk below, we will import the Nigeria LGA boundary shapefile data as a simple features data table into R environment using st_read() of sf package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnga <- st_read(dsn = \"data\", \n                 layer = \"nga_polnda_adm2_1m_salb\",\n                 crs = 4326) \n```\n:::\n\n\n## 2.2 Data Wrangling\n\n### 2.2.1 Recoding NA values into string\n\nIn the code chunk below, replace_na() of tidyr package is used to recode all the NA values in *status_cle* field into \"Unknown\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwp_nga <- read_rds(\"data/wp_nga.rds\") %>%\n  mutate(status_cle = replace_na(status_cle, \"Unknown\"))\n```\n:::\n\n\n### 2.2.2 EDA\n\nIn the code chunks below, freq() of funModeling package is used to display the distribution of *status_cle* field in *wp_nga*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfreq(data = wp_nga,\n     input = \"status_cle\")\n```\n:::\n\n\n### 2.2.3 Extracting functional water point\n\nIn the code chunk below, filter() of dplyr is used to select functional water points.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwpt_functional <- wp_nga %>%\n  filter(status_cle %in%\n           c(\"Functional\",\n             \"Functional but not in use\",\n             \"Functional but needs repair\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfreq(data= wpt_functional,\n     input = \"status_cle\")\n```\n:::\n\n\n### 2.2.4 Extracting non-functional water point\n\nIn the code chunk below, filter() of dplyr is used to select non-functional water points.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwpt_nonfunctional <- wp_nga %>%\n  filter(status_cle %in%\n           c(\"Abandoned/Decommissioned\",\n             \"Abandoned\",\n             \"Non-Functional\",\n             \"Non functional due to dry season\",\n             \"Non-Functional due to dry season\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfreq(data = wpt_nonfunctional,\n     input = \"status_cle\")\n```\n:::\n\n\n### 2.2.5 Extracting water point with Unknown Class\n\nIn the code chunk below, filter() of dplyr is used to select water points with unknown status.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwpt_unknown <- wp_nga %>%\n  filter(status_cle == \"Unknown\")\n```\n:::\n\n\n### 2.2.6 Performing Point-in-Polygon Count\n\nIn the code chunk below, st_intersects() of sf is used to identify water points located in each Nigerian province; *lengths()* of Base R is used to calculate numbers of water points that fall inside each province, and mutate() of dplyr package is used to derive four fields, namely: (a) total wpt, (b) wpt functional, (c) wpt non-functional, (d) wpt unknown.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnga_wp <- nga %>% \n  mutate(`total wpt` = lengths(\n    st_intersects(nga, wp_nga))) %>%\n  mutate(`wpt functional` = lengths(\n    st_intersects(nga, wpt_functional))) %>%\n  mutate(`wpt non-functional` = lengths(\n    st_intersects(nga, wpt_nonfunctional))) %>%\n  mutate(`wpt unknown` = lengths(\n    st_intersects(nga, wpt_unknown)))\n```\n:::\n\n\n### 2.2.7 Saving the Analytical Data Table\n\nIn the code chunk below, mutate() of dplyr package is used to drive two fields, namely pct_functional and pct non-functional. To keep the file size small, select() of dplyr is used to retain only fields 3,4,9,10,18,19,20,21,22 and 23.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnga_wp <- nga_wp %>% \n  mutate(`pct_functional` = `wpt functional` / `total wpt`) %>%\n  mutate(`pct_non-functional` = `wpt non-functional`/ `total wpt`) #%>%\n#  select(3:4, 9:10, 18:23)\n```\n:::\n\n\nNext, write_rds() of readr package is used to save the extracted sf data table into an output file in rds data format, and saved in the data sub-folder.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(nga_wp, \"data/nga_wp.rds\")\n```\n:::\n\n\n# 3. Visualising the spatial distribution of water points\n\nIn the code chunk below, qtm() of tmap package is used to plot the thematic maps depicting Nigeria waterpoints quickly, while tmap_arrange() is used to create multiple stand-alone maps .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnga_wp <- read_rds(\"data/nga_wp.rds\")\ntotal <- qtm(nga_wp, \"total wpt\")\nwp_functional <- qtm(nga_wp, \"wpt functional\")\nwp_nonfunctional <- qtm(nga_wp, \"wpt non-functional\")\nunknown <- qtm(nga_wp, \"wpt unknown\")\n\ntmap_arrange(total, wp_functional, wp_nonfunctional, unknown, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex1_files/figure-html/unnamed-chunk-15-1.png){width=1344}\n:::\n:::\n\n\n# 4. Computing contiguity spatial weights\n\nBuilding a neighbours list based on regions with contiguous boundaries\n\n## 4.1 Computing (QUEEN) contiguity based neighbours\n\nIn the code chunk below, poly2nb() of spdep package is used to compute the Queen contiguity weight matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- poly2nb(nga_wp, queen = TRUE)\nsummary(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 773 \nNumber of nonzero links: 4484 \nPercentage nonzero weights: 0.7504238 \nAverage number of links: 5.800776 \nLink number distribution:\n\n  1   2   3   4   5   6   7   8   9  10  11  12  13 \n  2  13  53 117 178 156 121  71  41  15   4   1   1 \n2 least connected regions:\n475 505 with 1 link\n1 most connected region:\n516 with 13 links\n```\n:::\n:::\n\n\nThe summary report above shows that there are 773 area units in Nigeria. The most connected area unit has 13 neighbours, while 2 area units only have one neighbour.\n\n## 4.2 Visualising contiguity weights\n\nA connectivity graph takes a point and displays a line to each neighboring point. We are working with polygons at the moment, so we will need to get points in order to make our connectivity graphs. The most typically method for this will be polygon centroids. We will calculate these in the sf package before moving onto the graphs.\n\nTo get our longitude values we map the st_centroid function over the geometry column of us.bound and access the longitude value through double bracket notation \\[\\[\\]\\] and 1. This allows us to get only the\nlongitude, which is the first value in each centroid.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlongitude <- map_dbl(nga_wp$geometry, ~st_centroid(.x)[[1]])\n```\n:::\n\n\nWe will do the same for latitude with one key difference, in that we access the second value per centroid with \\[\\[2\\]\\].\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlatitude <- map_dbl(nga_wp$geometry, ~st_centroid(.x)[[2]])\n```\n:::\n\n\nNow that we have latitude and longitude, we use cbind to put longitude and latitude into the same object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords <- cbind(longitude, latitude)\n```\n:::\n\n\nChecking the first few observations to see if things are formatted correctly\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(coords)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     longitude latitude\n[1,]  7.371644 5.106900\n[2,]  7.350650 5.081346\n[3,]  7.807885 5.515729\n[4,]  7.610951 5.664240\n[5,]  7.584973 5.406009\n[6,]  7.401408 5.290573\n```\n:::\n:::\n\n\n### \n4.2.1 Plotting Queen contiguity based neighbours map\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(nga_wp$geometry, border = \"lightgrey\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"red\")\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex1_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n# 5. Computing distance based neighbours\n\nThe function identifies neighbours of region points by Euclidean distance with a distance band with lower d1= and upper d2= bounds\ncontrolled by the bounds= argument. If unprojected coordinates are used and either specified in the coordinates object x or with x as a two column matrix and longlat=TRUE, great circle distances in **km** will be calculated with the WGS84 reference ellipsoid.\n\n## 5.1 Determining the cut-off distance\n\nWe will first determine the upper limit for distance band by using the steps below:\n\n-   Return a matrix with the indices of points belonging to the set of the k nearest neighbours of each other by using [*knearneigh()*](https://r-spatial.github.io/spdep/reference/knearneigh.html) of spdep.\n\n-   Convert the knn object returned by *knearneigh()* into a neighbours list of class nb with a list of integer vectors containing neighbour region number ids by using [*knn2nb()*](https://r-spatial.github.io/spdep/reference/knn2nb.html).\n\n-   Return the length of neighbour relationship edges by using [*nbdists()*](https://r-spatial.github.io/spdep/reference/nbdists.html) of spdep. The function returns in the units of the coordinates if the coordinates are projected, in km otherwise.\n\n-   Remove the list structure of the returned object by using [**unlist()**](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/unlist).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk1 <- knn2nb(knearneigh(coords))\nk1dists <- unlist(nbdists(k1, coords, longlat = TRUE))\nsummary(k1dists)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  3.001  12.555  20.575  22.026  28.240  71.769 \n```\n:::\n:::\n\n\nThe summary report shows that the largest first neighbour distance is 71.769k, so using this as the upper threshold gives certainty that all units will have at least one neighbour.\n\n## 5.2 Computing fixed distance weight matrix\n\nUsing the code chunk below, we will compute the distance weight matrix using dnearneigh() of spdep.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_d72 <- dnearneigh(coords, 0, 72, longlat = TRUE)\nwm_d72\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 773 \nNumber of nonzero links: 18114 \nPercentage nonzero weights: 3.031485 \nAverage number of links: 23.43338 \n```\n:::\n:::\n\n\nThe summary report above shows that on average, each area unit is nearest in distance to another 23 area units.\n\n### 5.2.1 Plotting fixed distance weight matrix\n\nUsing the code chunk below, we will plot the distance weight matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(1,2))\nplot(nga_wp$geometry, border = \"lightgrey\")\nplot(k1, coords, add=TRUE, col=\"red\", length = 0.08)\nplot(nga_wp$geometry, border = \"lightgrey\")\nplot(wm_d72, coords, add=TRUE)\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex1_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Take-Home_Ex1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}