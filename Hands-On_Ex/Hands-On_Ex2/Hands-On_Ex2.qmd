---
title: "Hands-On_Ex2"
author: "Roger"
editor: visual
---

# Overview

Learning how to compute Global and Local Measure of Spatial Autocorrelation (GLSA).

In spatial policy, one of the main development objective of the local government and planners is to ensure equal development in the province. The task is to apply appropriate spatial stastistical methods to discover if the development are evenly distributed geographically.

-   if the answer is No, then next question is whether there are signs of spatial clustering

    -   If the answer is Yes, then the follow on question is where are these clusters

## Getting Started

Setting the analytical tools

```{r}
pacman::p_load(sf, spdep, tmap, tidyverse)
```

Importing the data into the r environment

```{r}
hunan <- st_read(dsn = "data/geospatial",
                 layer = "Hunan")
```

```{r}
hunan2012 <- read_csv("data/aspatial/Hunan_2012.csv")
```

Performing relational join

```{r}
hunan <- left_join(hunan, hunan2012)
```

Visualising regional development indicator

Preparing a basemap and choropleth map showing the distribution of GDPPC 2012 by using qtm()

```{r}
equal <- tm_shape(hunan)+
  tm_fill("GDPPC",
          n=5,
          style="equal")+
  tm_borders(alpha=0.5)+
  tm_layout(main.title = "Equal interval classification")

quantile <- tm_shape(hunan)+
  tm_fill("GDPPC",
          n=5,
          style = "quantile")+
  tm_borders(alpha=0.5)+
  tm_layout(main.title = "Equal quantile classification")

tmap_arrange(equal, 
             quantile,
             asp=1,
             ncol=2)
```

## Global spatial autocorrelation

Computing global spatial autocorrelation statistics [**and**]{.underline} performing spatial complete randomness test for global spatial autocorrelation

### Computing contiguity spatial weights

First, construct spatial weights of the study area, which will be used to define the neighbourhood relationships between geographical units (aka counties) in the study area

Computing Queen contiguity weight matrix

*the summary report shows there are 88 area units in Hunan, most connected area unit has 11 neighbours, while two area units only have 1 neighbour*

```{r}
wm_q <- poly2nb(hunan,
                queen = TRUE)
summary(wm_q)
```

### Row-standardised weights matrix

Assigning weights to each neighbouring polygon (e.g. each neighbouring polygon will be assigned equal weight (style = "W"), by assigning fraction 1/(no. of neighbours), then summing the weighted income values

Drawback in that polygons along the edges of the study area will base their lagged values on fewer polygons thus potentially over- or under- estimating the true nature of the spatial auto-correlation (other more robust options are available, e.g. style = "B")

*zero.policy=TRUE option allows for list of non-neighbours*

```{r}
rswm_q <- nb2listw(wm_q,
                   style="W",
                   zero.policy = TRUE)
rswm_q
```

Input of nb2listw() must be an object of class nb. The syntax has two major arguments, namely style and zero.policy:

-   Style: can take the following values:

    -   "W" - row standardised (sums over all links to n)

    -   "B" - basic binary coding

    -   "C" - globally standardised (sums over all links to n)

    -   "U" - equal to C divided by number of neighbours (sums over all links to unity)

    -   "minmax" - divides the weights by the minimum of the maximum row sums and maximum column sums of the input weights (similar to "C" and "U" styles)

    -   "S" - variance-stabilizing coding scheme

-   zero.policy: if set to TRUE, weights vectors of zero length are inserted for regions without neighbour in the neighbours list, which in turn generate lag values of zero.

### Global spatial autocorrelation: Moran's I

Perfoming Moran's I statistical testing using moran.test()

```{r}
moran.test(hunan$GDPPC,
           listw = rswm_q,
           zero.policy = TRUE,
           na.action = na.omit)
```

#### Computing Monte Carlo Moran's I

Performs permutation test for Moran's I statistic using moran.mc() *(1,000 simulations will be performed)*

```{r}
set.seed(1234)
bperm = moran.mc(hunan$GDPPC,
                 listw = rswm_q,
                 nsim = 999,
                 zero.policy = TRUE,
                 na.action = na.omit)
bperm
```

#### Visualising Monte Carlo Moran's I

Examining simulated Moran's I test statistics in greater detail, by plotting the distribution of the statistical values as a histogram

```{r}
mean(bperm$res[1:999])
```

```{r}
var(bperm$res[1:999])
```

```{r}
summary(bperm$res[1:999])
```

```{r}
hist(bperm$res,
     freq = TRUE,
     breaks=20,
     xlab = "Simulated Moran's I")
abline(v=0,
       col="red")
```

### Global spatial autocorrelation: Geary's

Performing Geary's c statistics

#### Geary's c test

Perfoming Geary's C test for spatial autocorrelation using geary.test()

```{r}
geary.test(hunan$GDPPC, listw=rswm_q)
```

#### Computing Monte Carlo Geary's C

Performing permutation test for Geary's C statistics using geary.mc()

```{r}
set.seed(1234)
bperm=geary.mc(hunan$GDPPC,
               listw=rswm_q,
               nsim=999)
bperm
```

#### Visualising Monte Carlo Geary's C

```{r}
mean(bperm$res[1:999])
```

```{r}
var(bperm$res[1:999])
```

```{r}
summary(bperm$res[1:999])
```

```{r}
hist(bperm$res, freq=TRUE, breaks=20, xlab="Simulated Geary C")
abline(v=1, col="red")
```

## Spatial Correlogram

Examining patterns of spatial autocorrelation or model residuals. They show how correlated are pairs of spatial observations when distance(lag) is increased between them. They are plots of some index of autocorrelation against distance.

### Compute Moran's I correlogram

Computing a 6-lag spatial correlogram. The global spatial autocorrelation used in Moran's I, then plot the output using plot()

```{r}
MI_corr <- sp.correlogram(wm_q,
                          hunan$GDPPC,
                          order=6,
                          method="I",
                          style="W")
plot(MI_corr)
```

Note: not all autocorrelation are statistically significant. Hence it is important to examine the full analysis

```{r}
print(MI_corr)
```

### Compute Geary's C correlogram and plot

Computing a 6-lag spatial correlogram, using sp.correlogram(). The global spatial autocorrelation used in Geary's C and plotting its output using plot()

```{r}
GC_corr <- sp.correlogram(wm_q,
                          hunan$GDPPC,
                          order=6,
                          method="C",
                          style="W")
plot(GC_corr)
```

Similarly, printing the analysis report

```{r}
print(GC_corr)
```

## Cluster and outlier analysis

Local indicators of spatial association(aka LISA) are statistics that evaluate the existence of clusters in the spatial arrangement of a given variable. For instance, if the study is on cancer rates among census tracts in a given city local clusters in the rates, means there are areas that have higher r lower rates is to be expected by chance alone

### Computing local Moran's I

Computing local Moran's I using localmoran(). It computes li values, given a set of zi alues and a listw object providing neighbour weighting information for the polygon associated with the zi values

```{r}
fips <- order(hunan$County)
localMI <- localmoran(hunan$GDPPC, rswm_q)
head(localMI)
```

localmoran() returns a matrix of values whose columns are:

-   li : local Moran's I statistics

-   E.li : expectation of local moran statistics under randomisation hypothesis

-   Var.li : variance of local moran statistics under randomisation hypothesis

-   Z.li : standard deviation of local moran statistics

-   Pr() : p-values of local moran statistics

```{r}
printCoefmat(data.frame(localMI[fips], row.names=hunan$County[fips]), check.names=FALSE)
```

#### Mapping the local Moran's I

First, append the local Moran's I dataframe onto hunan SpatialPolygonDataFrame

```{r}
hunan.localMI <- cbind(hunan, localMI) %>%
  rename(Pr.Ii = Pr.z....E.Ii..)
```

#### Mapping local Moran's I values

Plotting local Moran's I vlaues using choropleth mapping functions

```{r}
tm_shape(hunan.localMI)+
  tm_fill(col = "Ii",
          style = "pretty",
          palette = "RdBu",
          title = "local moran statistics")+
  tm_borders(alpha=0.5)
```

***\-\-- to be continued - - -***
