---
title: "In-Class_Ex1"
author: "Roger"
editor: visual
---

# Overview

Computing spatial weights using R

```{r}
packages = c('sf', 'spdep', 'tmap', 'tidyverse')
for (p in packages){
  if(!require(p, character.only = T)){
    install.packages(p)
  }
  library(p,character.only = T)
}
```

## Importing the data

Importing shapefile as simple features object of sf

```{r}
hunan <- st_read(dsn = "data/geospatial", 
                 layer = "Hunan")
```

Importing csv file as R dataframe class

```{r}
hunan2012 <- read_csv("data/aspatial/Hunan_2012.csv")
```

Performing relational join

```{r}
hunan <- left_join(hunan,hunan2012)
```

## Visualising regional development indicator

Preparing basemap and choropleth map showing the distribution of GDPPC2012 by using qtm()

```{r}
basemap <- tm_shape(hunan) +
  tm_polygons() +
  tm_text("NAME_3", size=0.5)

gdppc <- qtm(hunan, "GDPPC")
tmap_arrange(basemap, gdppc, asp=1, ncol=2)
```

## Computing contiguity spatial weights

Building a neighbours list based on regions with contiguous boundaries

### Computing(QUEEN) contiguity based neighbours

Computing Queen contiguity weight matrix

```{r}
wm_q <- poly2nb(hunan, queen=TRUE)
summary(wm_q)
```

Seeing the neighbours for the first polygon in the object

```{r}
wm_q[[1]]
```

Retrieving country name of polygonID=1

```{r}
hunan$County[1]
```

Revealing county names of five neighbouring polygons

```{r}
hunan$NAME_3[c(2,3,4,57,85)]
```

Retrieving the GDPPC of these five counties

```{r}
nb1 <- wm_q[[1]]
nb1 <- hunan$GDPPC[nb1]
nb1
```

Displaying the complete weight matrix using str()

```{r}
str(wm_q)
```

### Creating (ROOK) contiguity based neighbours

Computing Rook contiguity weight matrix

```{r}
wm_r <- poly2nb(hunan, queen=FALSE)
summary(wm_r)
```

### Visualising contiguity weights

To get longitude values, map st_centroid function over the geometry column of us.bound and access the longitude value through double bracket notation \[\[\]\]and 1.

```{r}
longitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])
```

Doing the same for latitude, BUT accessing the second value per each centroid with \[\[2\]\]

```{r}
latitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])
```

Putting longitude and latitude together with cbind

```{r}
coords <- cbind(longitude, latitude)
```

Checking the first few observations for correct formatting

```{r}
head(coords)
```

#### Plotting Queen contiguity based neighbours map

```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red")
```

#### Plotting Rook contiguity based neighbours map

```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

#### Plotting both Queen and Rook contiguity based neighbours map

```{r}
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red", main="Queen Contiguity")
plot(hunan$geometry, border="lightgrey")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red", main="Rook Contiguity")
```

## Computing distance based neighbours

Identifying neighbours of region points by Euclidean distance with a distance band with lower d1= and upper d2= bounds controlled by the bounds= argument.

### Determine the cut off distance

Determining the upper limit for distance band by:

-   Returning a matrix with the indices of points belonging to the set of the k nearest neighbours of each other using knearneigh()

-   Converting the knn object into a neighbours list of class nd with a list of integer vectors containing neighbour region ids by using knn2nb()

-   Returning the length of neighbour relationship edges by using nbdists()

-   Removing the list structure of returned objects by using unlist()

```{r}
#coords <- coordinates(hunan)

k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))
summary(k1dists)
```

### Computing fixed distance weight matrix

Computing distance weight matrix using dnearneigh()

```{r}
wm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)
wm_d62
```

*Average number of links means that on average, each region point area is nearest in distance to another 3.68 point areas*

Displaying the content of wm_d62 weight matrix

```{r}
str(wm_d62)
```

Another way to display the structure of the weight matrix is to combine table() and card()

```{r}
table(hunan$County, card(wm_d62))
```

```{r}
n_comp <- n.comp.nb(wm_d62)
n_comp$nc
```

```{r}
table(n_comp$comp.id)
```

#### Plotting fixed distance weight matrix

Plotting distance weight matrix

The red lines show the links of 1st nearest neighbours and black lines show links of neighbours within the cut-off distance of 62km

```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_d62, coords, add=TRUE)
plot(k1, coords, add=TRUE, col="red", length=0.08)
```

Alternatively, we can plot both of them next to each other

```{r}
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey")
plot(k1, coords, add=TRUE, col="red", length=0.08, main="1st nearest neighbours")
plot(hunan$geometry, border="lightgrey")
plot(wm_d62, coords, add=TRUE, pch = 19, cex = 0.6, main="Distance link")
```

***\-\-- to be continued \-\--***
